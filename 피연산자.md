# 피연산자

* 연산자의 정의된 연산을 하기위해 사용되는 레지스터나 상수, 레이블, 메모리 주소 등을 뜻하는 말
* 레지스터는 데이터를 저장하는 장치 중 속도가 가장 빠른 장소이므로, 일부 레지스터만 사용 가능
* 더 적은 레지스터를 필요로 하는 순서로 연산을 수행함으로써 더 많은 피연산자를 레지스터에 할당할 수 있게 된다.

&nbsp;  

## 피연산자 데이터 단위

| 데이터 단위 | 크기   |
| ----------- | ------ |
| word        | 32 bit |
| half word   | 16 bit |
| byte        | 8 bit  |

MIPS 명령어(instruction) 및 레지스터는 32비트로 구성되어 있음 (연산자 1byte, 피연산자 3byte)

&nbsp;  

**연습문제 1**

```pseudocode
// $s0 = F, $s1 = G, $s2 = H, $s3 = I, $s4 = J
// F = (G + H) - (I + J)를 MIPS 명령어로 표현

add $t0, $s1, $s2 // $t0 레지스터에 G + H의 값을 임시 저장
add $t1, $s3, #s4 // $t1 레지스터에 I + J의 값을 임시 저장
sub $s0, $t0, $t1 // $s0 레지스터에 $t0 + $t1의 값을 저장
```

&nbsp;  

## 메모리 주소 접근

### 메모리 피연산자

* 프로그래밍 언어에는 단순 변수가 아닌 자료형이 존재
* 레지스터는 소량의 데이터만 저장할 수 있기 때문에 나머지 데이터는 메모리(heap, stack)에 저장 후 주소에 접근하여 사용
  * Heap: 동적으로 할당되는 변수가 사용하는 공간
  * Stack: 정적으로 할당되는 변수가 사용하는 공간
* 메모리 <-> 레지스터간 데이터를 주고 받는 명령어를 **데이터 전송 명령어(Data Transfer Instruction)**이라고 함.

&nbsp;  

### 적재 명령어

* 메모리에서 -> 레지스터로 데이터를 복사해 오는 데이터 전송 명령어를 적재(load)라고 함
* 메모리는 주소가 인덱스의 역할을 하는 일차원 구조
* 적재 명령어는 연산자 (lw) + 값을 저장할 레지스터 + 메모리 접근에 사용할 상수 및 레지스터로 구성

&nbsp;  

**연습문제 2**

| 주소       | 데이터 |
| ---------- | ------ |
| 0x0000000C | 3      |
| 0x00000008 | 2      |
| 0x00000004 | 3      |
| 0x00000000 | 5      |

```pseudocode
// $s1 = g, $s2 = h, $s3 = 배열 A의 시작 주소
// g = h + A[1];

// $t0 레지스터에 배열 A의 시작 주소(base register)로부터 4byte 떨어진(offset) 메모리 공간의 값을 임시 저장
// $s1 레지스터에 $s2의 값과 $t0의 값을 더한 결과 값을 저장
lw $t0, 4($s3)
add $s1, $s2, $t0
```

&nbsp;  

### 저장 명령어

* 레지스터에서 -> 메모리로 데이터를 보내는 명령을 저장(store)이라고 함.
* 적재명령어와 같은 구조
* 연산자(sw) + 저장할 데이터를 가진 레지스터 + 메모리 주소 레지스터 및 상수(offset)의 조합

&nbsp;  

## 수치 피연산자

### 수치연산

* 프로그램 연산에서 레지스터가 아닌 상수를 사용하는 경우
* 사용 빈도가 높으면 상수를 명령어에 포함하는 것이 좋음
* 상수 필드를 갖는 산술 명령어를 사용시 메모리에 적재하는 것 보다 효율적